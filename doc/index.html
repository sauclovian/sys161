<html>
<head>
<title>System/161</title>
</head>
<body bgcolor=#ffffff>

<h2>System/161</h2>

System/161 is a synthetic (read: made up) hardware platform designed
specifically for use in CS161. It includes a simulated system bus and
bus devices, and any of several possible simulated CPUs.
<p>

The rest of this manual is divided into the following subsections:
<ul>
<li> <A HREF=#getting>Getting and Building System/161</A>
<li> <A HREF=#running>Running System/161</A>
<li> <A HREF=#config>Config files</A>
<li> <A HREF=#debug>Remote debugging with <tt>gdb</tt></A>
<li> <A HREF=#prog>Programming specs</A>
</ul>

<hr>
<A NAME=getting>

<h3>Getting System/161</h3>

If you are working on the Science Center ICE machines and have the
CS161 binary directory <tt>~lib161/usr/bin</tt> on your path, you can
run the version of System/161 installed by the course staff just by
typing <tt>sys161</tt> or <tt>trace161</tt>. You only need download
and compile it yourself if you want to work elsewhere.
<p>

The source distribution for System/161 can be found on the CS161 web
site, <A HREF=http://www.courses.fas.harvard.edu/~cs161>here</A>. It
supports most Unix-like systems. Windows is not supported. (However,
you might be able to compile it with cygwin or a similar toolset. If
you do this, you're on your own.)
<p>

All you need is sys161-1.0.tar.gz (or whatever the current version
is).
<p>

<h3>Building System/161</h3>

Unpack the distribution file by typing
<pre>
	tar -xvzf sys161-1.0.tar.gz
</pre>
(substitute whatever version you have for the 1.0.)
<p>

This will create a subdirectory called <tt>sys161-1.0</tt> with the
files in it. Go into this directory by typing
<pre>
	cd sys161-1.0
</pre>
(substitute whatever version you have for the 1.0.)
<p>

Now run the configure script. In the simple case, you do this by just
typing
<pre>
	./configure
</pre>
and letting it grind. If you want it to install the resulting programs
someplace other than <tt>~/cs161/root</tt>, pass configure the
<tt>--installdir</tt> option, like this:
<pre>
	./configure --installdir=$HOME/bin
</pre>
Note that, because of the way the Unix shell handles ~, if you use
<tt>~/bin</tt> instead of <tt>$HOME/bin</tt> it won't work.
<p>

Now go into the <tt>build</tt> directory, and from there into the
subdirectory to build the simulator you want. There are two kinds: the
"fast" simulator and the "trace" simulator. The "fast" simulator is
the normal one; the "trace" simulator prints every CPU instruction as
it's executed and some other info. (This can be useful if you suspect
a bug in System/161.) There may also be more than one processor type
supported.
<p>

Normally you want the "fast" simulator, and for CS161 this year, you
want the "mipseb" processor. So go into the directory
<tt>mipseb-fast</tt>.
<p>

Now type
<pre>
	make
</pre>
to compile, and
<pre>
	make install
</pre>
to install the simulator.
<p>

If it bombs, contact the course staff.
<p>

System/161 has been tested on the following platforms:
<ul>
<li> NetBSD on x86
<li> Digital Unix 4.0x on alpha
</ul>

<hr>
<A NAME=running>

<h3>Running System/161</h3>

There are two versions of System/161 that can be built: the normal
one, <tt>sys161</tt>, and one compiled to print every processor
instruction as it's executed, which is called <tt>trace161</tt>.
<p>

The general format for the command line for either of these is like
this:
<blockquote>
	<tt>sys161</tt> [ <em>System/161 options</em> ] 
		<em>kernel</em> [ <em>kernel options</em> ]
</blockquote>
<p>

The <em>System/161 options</em> are:
<blockquote>
<dl>
<dt>-c <em>configfile</em></dt>
<dd>Specify alternate config file. Default is <tt>sys161.conf</tt>.</dd>

<dt>-p <em>port</em></dt>
<dd>Listen for debugger connections on specified TCP port. The default
is to use the Unix-domain socket <tt>./.sockets/gdb</tt> for debugger
connections.</dd>

<dt>-w</dt>
<dd>Wait for a debugger connection immediately on startup.</dd>
</dl>
</blockquote>
<p>

The <em>kernel</em> is an operating system kernel to load and run. It
should be an ELF-format executable for the same processor type as
System/161 is compiled to support. For further information, see below.
<p>

Note that options found after the kernel name will be passed to the
kernel and not interpreted by System/161.
<p>

<hr>
<A NAME=config>

<h3>System/161 Config Files</h3>

System/161 reads a config file to determine what hardware it should
simulate. The default config file is <tt>./sys161.conf</tt>. A
different one can be specified with the <em>-c</em> option.
<p>

The config file is composed of lines in the following form:
<blockquote>
<em>slot-number</em> <em>device-name</em> [<em>args</em>...]
</blockquote>
<p>

Slots may be 0-31. You must place the bus controller card in slot 31,
or the system will not run.
<p>

Single-line comments are introduced with <tt>#</tt>.
<p>

The devices available, and the arguments they support, are:
<blockquote>
<table width=95%>

<tr>
<td colspan=2>busctl</td>
<td colspan=2><A HREF=lamebus.html>LAMEbus bus controller</A></td>
</tr>
<tr>
<td></td>
<td colspan=2><tt>ramsize=</tt><em>bytes</em></td>
<td>Specify size of physical RAM. Required.</td>
</tr>
<tr><td colspan=4>&nbsp;</td></tr>

<tr>
<td colspan=2>timer</td>
<td colspan=2><A HREF=devices.html#timer>CS161 timer device</A></td>
</tr>
<tr>
<td></td>
<td colspan=3><em>(no arguments)</td>
</tr>
<tr><td colspan=4>&nbsp;</td></tr>

<tr>
<td colspan=2>disk</td>
<td colspan=2><A HREF=devices.html#disk>CS161 disk device</A></td>
</tr>
<tr>
<td></td>
<td colspan=2><tt>rpm=</tt><em>cycles</em></td>
<td>Specify rotation speed. Must be multiple of 60. Default is 3600.</td>
</tr>
<tr>
<td></td>
<td colspan=2><tt>sectors=</tt><em>sectors</em></td>
<td>Specify number of 512-byte sectors on disk. Required.</td>
</tr>
<tr>
<td></td>
<td colspan=2><tt>file=</tt><em>filename</em></td>
<td>Filename to use for disk storage. Required.</td>
</tr>
<tr>
<td></td>
<td colspan=2><tt>paranoid</tt></td>
<td>If set, call fsync() on every disk write to hopefully ensure data
is not lost if the host system crashes. Slow and not recommended for
normal operation.</td>
</tr>
<tr><td colspan=4>&nbsp;</td></tr>

<tr>
<td colspan=2>serial</td>
<td colspan=2><A HREF=devices.html#serial>CS161 serial console</A></td>
</tr>
<tr>
<td></td>
<td colspan=3><em>(no arguments)</td>
</tr>
<tr><td colspan=4>&nbsp;</td></tr>

<tr>
<td colspan=2>screen</td>
<td colspan=2><A HREF=devices.html#screen>CS161 full-screen console</A></td>
</tr>
<tr>
<td></td>
<td colspan=3><em>(no arguments)</td>
</tr>
<tr><td></td><td colspan=3>Note: not available yet.</td></tr>
<tr><td colspan=4>&nbsp;</td></tr>

<tr>
<td colspan=2>nic</td>
<td colspan=2><A HREF=devices.html#nic>CS161 network interface</A></td>
</tr>
<tr>
<td></td>
<td colspan=3><em>(no arguments)</td>
</tr>
<tr><td></td><td colspan=3>Note: not available yet.</td></tr>
<tr><td colspan=4>&nbsp;</td></tr>

<tr>
<td colspan=2>emufs</td>
<td colspan=2><A HREF=devices.html#emufs>CS161/OS161 emulator
			pass-through filesystem</A></td>
</tr>
<tr>
<td></td>
<td colspan=2><tt>dir=</tt><em>directory</em></td>
<td>Directory to use as root of emufs filesystem. Default is <tt>.</tt>.</td>
</tr>
<tr><td colspan=4>&nbsp;</td></tr>

<tr>
<td colspan=2>random</td>
<td colspan=2><A HREF=devices.html#rand>CS161 random number generator</A></td>
</tr>
<tr>
<td></td>
<td colspan=2><tt>seed=</tt><em>number</em></td>
<td>Set seed for pseudo-random-number generator. Default is 0.</td>
</tr>
<tr>
<td></td>
<td colspan=2><tt>autoseed</tt></td>
<td>Set seed for pseudo-random-number generator based on the system clock.</td>
</tr>
<tr>
<td></td>
<td colspan=3>Note: if you have multiple random devices, they all
share the same randomizer state.</td>
</tr>

</table>
</blockquote>

<hr>
<A NAME=debug>

<h3>Kernel Debugging with <tt>gdb</tt></h3>

System/161 supports remote <tt>gdb</tt> debugging directly into the
simulator. The simulator acts like an in-circuit emulator (ICE), only
more so, so that you can debug without any interference whatsoever
with the debugged code - even timing is unaffected.
<p>

To do this, you need a copy of <tt>gdb</tt> compiled for the same
processor that System/161 is simulating, and that understands the
ELF kernel file format loaded by System/161. Get and compile
<A HREF=http://www.courses.fas.harvard.edu/~cs161/download>the CS161
toolchain</A>.
On the Science Center machines, you can just run <tt>cs161-gdb</tt>.
<p>

Run gdb as you normally would:
<pre>
	gdb kernel
</pre>

After it finishes loading, attach to System/161 by typing this into gdb:
<pre>
	target remote unix:.sockets/gdb
</pre>
and gdb will connect up to the copy of System/161 you have running in
the same directory and you can start debugging. (You can debug one in
another directory by specifying the right path to its socket.)
<p>

Since this is a painful thing to type every time you want to debug, we
recommend you create a shortcut for it. Put the following in a file
called <tt>.gdbinit</tt> in the same directory you're working in.
(gdb runs this file when you start it up.)
<pre>
	define db
	target remote unix:.sockets/gdb
	end
</pre>
Then you can connect up to System/161 for debugging just by running
gdb and typing "db".
<p>

If you give System/161 the <em>-w</em> option, it will stop and wait
for a debugger connection before it runs anything at all. This allows
you to start debugging from the very beginning of kernel initialization.
<p>

Theoretically everything you can do with gdb normally should work with
gdb connected this way. In practice, there are probably some problems.
Bring them to the attention of the course staff and we'll see if we
can get them fixed.
<p>

When System/161 is running, if you type ^G (control-G) into its
window, it will immediately stop in gdb (if gdb is attached) or wait
for a gdb connection (if gdb is not attached).
<p>

<hr>
<A NAME=prog>

<h3>System/161 Programming Information</h3>

At present, System/161 can be compiled to simulate only one fully
supported processor type: the MIPS r2000/r3000. There is partial
support for the Ant-32 processor as well, but this is incomplete and
not supported. It may not be present in the release tarfiles.
<p>

This page does not document MIPS r2000/r3000 programming. 
<!-- XXX we should have some links if there are any good ones. -->
<p>

The system bus used in System/161 is a simplified architecture made up
for the purpose; it is fittingly called LAMEbus. There are also a half
dozen or so simulated devices available.
<p>

<blockquote>
<A HREF=lamebus.html>LAMEbus programming info</A><br>
<A HREF=devices.html>System/161 LAMEbus devices</A><br>
</blockquote>
<p>

The kernel loaded by System/161 is (at present) loaded by the
simulator, not a boot ROM within the simulator. Thus, at present, any
of the memory regions described as being boot ROMs are in fact
unmapped and accesses to them will cause bus errors.
<p>

The kernel will be loaded into physical memory at an address chosen so
that it appears in kernel virtual memory at the virtual address it was
linked to be run at. (The desired address should be passed to the
linker at kernel build time.) Precisely what this means depends on the
processor and MMU in use. See the processor-specific pages listed at
the top of the <A HREF=lamebus.html>LAMEbus programming</A> page.
<p>

Control will be transferred to the entry point of the kernel specified
in the ELF file. The entry point will be called as if it were a C
function taking one argument: a string. This string contains the
kernel arguments passed on the System/161 command line, concatenated
with spaces.
<p>

Both the argument string and a small bootup stack, and possibly other
machine-dependent data, are located in the top few pages of physical
memory. The precise location is not specified and should not be
assumed. The kernel should establish its own stack, copy the string
to a known location elsewhere, and handle any other machine-dependent
data appropriately; then it can reuse the top of physical memory for
its own purposes.
<p>

</body>
</html>
